package com.lzlk.Ch1_java_base;

/**
 * TODO: 整数运算
 *
 * 在Java的计算表达式中，运算优先级从高到低依次是：
 *      ()
 *      ! ~ ++ --
 *      * / %
 *      + -
 *      << >> >>>
 *      &
 *      |
 *      += -= *= /=
 *
 * @Created by 湖南爱豆
 * @Date 2020/5/21 16 09
 * @Author: 邻座旅客
 */
public class OperationInteger {

    public static void main(String[] args) {
        // Java的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。
        int i = (100 + 200) * (99 - 88);
        int n = 7 * (5 + (i - 9));
        System.out.println("i = " + i); // 3300
        System.out.println("n = " + n); // 23072

        // 整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：
        int x = 100 / 3;
        System.out.println("x = " + x); // 33

        // 求余运算使用%：
        int y = 12 % 5;
        System.out.println("y = " + y); // 2

        /** 特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。 */

        overflow();

        selfIncrease();

        bitwise();

        typeConvert();
    }

    /**
     * 溢出
     *
     * 要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果：
     */
    public static void overflow() {
        int a1 = 2147483640;
        int a2 = 15;
        int sum1 = a1 + a2;
        System.out.println("sum1 = " + sum1); // -2147483641

        /*
        要解释上述结果，我们把整数2147483640和15换成二进制做加法：

          0111 1111 1111 1111 1111 1111 1111 1000
        + 0000 0000 0000 0000 0000 0000 0000 1111
        -----------------------------------------
          1000 0000 0000 0000 0000 0000 0000 0111

        由于最高位计算结果为1，因此，加法结果变成了一个负数。
         */

        // 要解决上面的问题，可以把int换成long类型，由于long可表示的整型范围更大，所以结果就不会溢出：
        long x1 = 2147483640L;
        long x2 = 15L;
        long sum2 = x1 + x2;
        System.out.println("sum2 = " + sum2); // 2147483655
    }

    /**
     * 自增/减
     *
     * Java提供了++运算和--运算，它们可以对一个整数进行加1和减1的操作。
     *
     * ++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。不建议把++运算混入到常规运算中，容易自己把自己搞懵了。
     */
    public static void selfIncrease() {
        int n = 3300;
        n++; // 3301, 相当于 n = n + 1;
        n--; // 3300, 相当于 n = n - 1;
        int y = 100 + (++n); // 不要这么写
        System.out.println("y = " + y);
    }

    /**
     * 位运算
     *
     * 位运算是按位进行与、或、非和异或的运算。
     */
    public static void bitwise() {
        int n;

        // 与运算的规则是，必须两个数同时为1，结果才为1：
        n = 0 & 0; // 0
        n = 0 & 1; // 0
        n = 1 & 0; // 0
        n = 1 & 1; // 1

        // 或运算的规则是，只要任意一个为1，结果就为1：
        n = 0 | 0; // 0
        n = 0 | 1; // 1
        n = 1 | 0; // 1
        n = 1 | 1; // 1

        // 非运算的规则是，0和1互换：
        n = ~0; // 1
        n = ~1; // 0

        // 异或运算的规则是，如果两个数不同，结果为1，否则为0：
        n = 0 ^ 0; // 0
        n = 0 ^ 1; // 1
        n = 1 ^ 0; // 1
        n = 1 ^ 1; // 0

        // 对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。
        int i = 167776589; // 00001010 00000000 00010001 01001101
        int j = 167776512; // 00001010 00000000 00010001 00000000
        System.out.println(i & j); // 167776512

        // 上述按位与运算实际上可以看作两个整数表示的IP地址10.0.17.77和10.0.17.0，通过与运算，可以快速判断一个IP是否在给定的网段内。
    }

    /**
     * 类型转换
     */
    public static void typeConvert() {

        // 自动转型：
        // 在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。
        // 例如，short和int计算，结果总是int，原因是short首先自动被转型为int：
        short s = 1234;
        int i = 123456;
        int x = s + i; // s自动转型为int
//        short y = s + i; // 编译错误!

        // 强转：
        // 将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用(类型)，例如，将int强制转型为short：
        int b = 12345;
        short c = (short) b; // 12345

        // 要注意，超出范围的强制转型会得到错误的结果，原因是转型时，int的两个高位字节直接被扔掉，仅保留了低位的两个字节：
        int i1 = 1234567;
        short s1 = (short) i1;
        System.out.println(s1); // -10617
        int i2 = 12345678;
        short s2 = (short) i2;
        System.out.println(s2); // 24910
        // 因此，强制转型的结果很可能是错的。

        /** 整数运算的结果永远是精确的；
         * 运算结果会自动提升；
         * 可以强制转型，但超出范围的强制转型会得到错误的结果；
         * 应该选择合适范围的整型（int或long），没有必要为了节省内存而使用byte和short进行整数运算。*/
    }
}
